deque(['$', 'START'])
START --> [<function createLeafEpsilon at 0x000002589AA432E0>, 'PROG', <function createProgNode at 0x000002589AA58550>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'PROG'])
PROG --> ['REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['STRUCTDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTDECL'])
STRUCTDECL --> ['struct', 'id', <function createLeaf at 0x0000025899A30700>, <function createLeafEpsilon at 0x000002589AA432E0>, 'OPTSTRUCTDECL2', <function createInheritsNode at 0x000002589AA43C70>, <function createStructDefNode at 0x000002589AA43D00>, <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr', 'REPTSTRUCTDECL4', <function createStructBodyNode at 0x000002589AA43D90>, 'rcurbr', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2', <function createLeafEpsilon at 0x000002589AA432E0>, <function createLeaf at 0x0000025899A30700>, 'id', 'struct'])
struct --> struct

struct
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2', <function createLeafEpsilon at 0x000002589AA432E0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2'])
OPTSTRUCTDECL2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['public']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'public'])
public --> public

struct polynomial {
    public
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['FUNCDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'FUNCDECL'])
FUNCDECL --> ['FUNCHEAD', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['public']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'public'])
public --> public

struct polynomial {
    public func evaluate(x: float) -> float;
    public
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['FUNCDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'FUNCDECL'])
FUNCDECL --> ['FUNCHEAD', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
}
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['STRUCTDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTDECL'])
STRUCTDECL --> ['struct', 'id', <function createLeaf at 0x0000025899A30700>, <function createLeafEpsilon at 0x000002589AA432E0>, 'OPTSTRUCTDECL2', <function createInheritsNode at 0x000002589AA43C70>, <function createStructDefNode at 0x000002589AA43D00>, <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr', 'REPTSTRUCTDECL4', <function createStructBodyNode at 0x000002589AA43D90>, 'rcurbr', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2', <function createLeafEpsilon at 0x000002589AA432E0>, <function createLeaf at 0x0000025899A30700>, 'id', 'struct'])
struct --> struct

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2', <function createLeafEpsilon at 0x000002589AA432E0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2'])
OPTSTRUCTDECL2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['public']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'public'])
public --> public

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['FUNCDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'FUNCDECL'])
FUNCDECL --> ['FUNCHEAD', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['public']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'public'])
public --> public

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['FUNCDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'FUNCDECL'])
FUNCDECL --> ['FUNCHEAD', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
}
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['STRUCTDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTDECL'])
STRUCTDECL --> ['struct', 'id', <function createLeaf at 0x0000025899A30700>, <function createLeafEpsilon at 0x000002589AA432E0>, 'OPTSTRUCTDECL2', <function createInheritsNode at 0x000002589AA43C70>, <function createStructDefNode at 0x000002589AA43D00>, <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr', 'REPTSTRUCTDECL4', <function createStructBodyNode at 0x000002589AA43D90>, 'rcurbr', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2', <function createLeafEpsilon at 0x000002589AA432E0>, <function createLeaf at 0x0000025899A30700>, 'id', 'struct'])
struct --> struct

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2', <function createLeafEpsilon at 0x000002589AA432E0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2'])
OPTSTRUCTDECL2 --> ['inherits', 'id', <function createLeaf at 0x0000025899A30700>, 'REPTOPTSTRUCTDECL22']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22', <function createLeaf at 0x0000025899A30700>, 'id', 'inherits'])
inherits --> inherits

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22'])
REPTOPTSTRUCTDECL22 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['private']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'private'])
private --> private

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['private']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'private'])
private --> private

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['private']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'private'])
private --> private

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['public']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'public'])
public --> public

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['FUNCDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'FUNCDECL'])
FUNCDECL --> ['FUNCHEAD', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['FPARAMSTAIL', <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, 'FPARAMSTAIL'])
FPARAMSTAIL --> ['comma', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMSTAIL4', <function createDimNode at 0x000002589AA43370>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4'])
REPTFPARAMSTAIL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['id']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['public']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'public'])
public --> public

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['FUNCDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'FUNCDECL'])
FUNCDECL --> ['FUNCHEAD', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
}
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['STRUCTDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTDECL'])
STRUCTDECL --> ['struct', 'id', <function createLeaf at 0x0000025899A30700>, <function createLeafEpsilon at 0x000002589AA432E0>, 'OPTSTRUCTDECL2', <function createInheritsNode at 0x000002589AA43C70>, <function createStructDefNode at 0x000002589AA43D00>, <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr', 'REPTSTRUCTDECL4', <function createStructBodyNode at 0x000002589AA43D90>, 'rcurbr', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2', <function createLeafEpsilon at 0x000002589AA432E0>, <function createLeaf at 0x0000025899A30700>, 'id', 'struct'])
struct --> struct

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2', <function createLeafEpsilon at 0x000002589AA432E0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2'])
OPTSTRUCTDECL2 --> ['inherits', 'id', <function createLeaf at 0x0000025899A30700>, 'REPTOPTSTRUCTDECL22']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22', <function createLeaf at 0x0000025899A30700>, 'id', 'inherits'])
inherits --> inherits

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22'])
REPTOPTSTRUCTDECL22 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['private']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'private'])
private --> private

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['private']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'private'])
private --> private

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['private']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'private'])
private --> private

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['public']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'public'])
public --> public

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['FUNCDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'FUNCDECL'])
FUNCDECL --> ['FUNCHEAD', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['FPARAMSTAIL', <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, 'FPARAMSTAIL'])
FPARAMSTAIL --> ['comma', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMSTAIL4', <function createDimNode at 0x000002589AA43370>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4'])
REPTFPARAMSTAIL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['FPARAMSTAIL', <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, 'FPARAMSTAIL'])
FPARAMSTAIL --> ['comma', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMSTAIL4', <function createDimNode at 0x000002589AA43370>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4'])
REPTFPARAMSTAIL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['id']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['public']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'public'])
public --> public

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['FUNCDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'FUNCDECL'])
FUNCDECL --> ['FUNCHEAD', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
}
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['STRUCTDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTDECL'])
STRUCTDECL --> ['struct', 'id', <function createLeaf at 0x0000025899A30700>, <function createLeafEpsilon at 0x000002589AA432E0>, 'OPTSTRUCTDECL2', <function createInheritsNode at 0x000002589AA43C70>, <function createStructDefNode at 0x000002589AA43D00>, <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr', 'REPTSTRUCTDECL4', <function createStructBodyNode at 0x000002589AA43D90>, 'rcurbr', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2', <function createLeafEpsilon at 0x000002589AA432E0>, <function createLeaf at 0x0000025899A30700>, 'id', 'struct'])
struct --> struct

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2', <function createLeafEpsilon at 0x000002589AA432E0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2'])
OPTSTRUCTDECL2 --> ['inherits', 'id', <function createLeaf at 0x0000025899A30700>, 'REPTOPTSTRUCTDECL22']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22', <function createLeaf at 0x0000025899A30700>, 'id', 'inherits'])
inherits --> inherits

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22'])
REPTOPTSTRUCTDECL22 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['private']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'private'])
private --> private

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
}
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['STRUCTDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTDECL'])
STRUCTDECL --> ['struct', 'id', <function createLeaf at 0x0000025899A30700>, <function createLeafEpsilon at 0x000002589AA432E0>, 'OPTSTRUCTDECL2', <function createInheritsNode at 0x000002589AA43C70>, <function createStructDefNode at 0x000002589AA43D00>, <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr', 'REPTSTRUCTDECL4', <function createStructBodyNode at 0x000002589AA43D90>, 'rcurbr', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2', <function createLeafEpsilon at 0x000002589AA432E0>, <function createLeaf at 0x0000025899A30700>, 'id', 'struct'])
struct --> struct

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2', <function createLeafEpsilon at 0x000002589AA432E0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2'])
OPTSTRUCTDECL2 --> ['inherits', 'id', <function createLeaf at 0x0000025899A30700>, 'REPTOPTSTRUCTDECL22']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22', <function createLeaf at 0x0000025899A30700>, 'id', 'inherits'])
inherits --> inherits

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22'])
REPTOPTSTRUCTDECL22 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['private']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'private'])
private --> private

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
}
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['STRUCTDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTDECL'])
STRUCTDECL --> ['struct', 'id', <function createLeaf at 0x0000025899A30700>, <function createLeafEpsilon at 0x000002589AA432E0>, 'OPTSTRUCTDECL2', <function createInheritsNode at 0x000002589AA43C70>, <function createStructDefNode at 0x000002589AA43D00>, <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr', 'REPTSTRUCTDECL4', <function createStructBodyNode at 0x000002589AA43D90>, 'rcurbr', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2', <function createLeafEpsilon at 0x000002589AA432E0>, <function createLeaf at 0x0000025899A30700>, 'id', 'struct'])
struct --> struct

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2', <function createLeafEpsilon at 0x000002589AA432E0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'OPTSTRUCTDECL2'])
OPTSTRUCTDECL2 --> ['inherits', 'id', <function createLeaf at 0x0000025899A30700>, 'REPTOPTSTRUCTDECL22']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22', <function createLeaf at 0x0000025899A30700>, 'id', 'inherits'])
inherits --> inherits

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'REPTOPTSTRUCTDECL22'])
REPTOPTSTRUCTDECL22 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, <function createStructDefNode at 0x000002589AA43D00>, <function createInheritsNode at 0x000002589AA43C70>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['VISIBILITY', <function createLeafVisibility at 0x000002589AA431C0>, 'MEMBERDECL', <function createStructDeclNode at 0x000002589AA43E20>, 'REPTSTRUCTDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'VISIBILITY'])
VISIBILITY --> ['private']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL', <function createLeafVisibility at 0x000002589AA431C0>, 'private'])
private --> private

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'MEMBERDECL'])
MEMBERDECL --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4', <function createStructDeclNode at 0x000002589AA43E20>, 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'REPTSTRUCTDECL4'])
REPTSTRUCTDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr', <function createStructBodyNode at 0x000002589AA43D90>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
}
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['IMPLDEF']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'IMPLDEF'])
IMPLDEF --> ['impl', 'id', <function createLeaf at 0x0000025899A30700>, <function createImplDefNode at 0x000002589AA43EB0>, 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'REPTIMPLDEF3', <function createImplBodyNode at 0x000002589AA43F40>, 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr', <function createImplDefNode at 0x000002589AA43EB0>, <function createLeaf at 0x0000025899A30700>, 'id', 'impl'])
impl --> impl

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr', <function createImplDefNode at 0x000002589AA43EB0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3'])
REPTIMPLDEF3 --> ['FUNCDEF', 'REPTIMPLDEF3']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCDEF'])
FUNCDEF --> ['FUNCHEAD', 'FUNCBODY']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY'])
FUNCBODY --> ['lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'REPTFUNCBODY1', <function createFuncBodyNode at 0x000002589AA43BE0>, 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['return', 'lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createReturnNode at 0x000002589AA436D0>, 'rpar', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar', 'return'])
return --> return

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3'])
REPTIMPLDEF3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['IMPLDEF']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'IMPLDEF'])
IMPLDEF --> ['impl', 'id', <function createLeaf at 0x0000025899A30700>, <function createImplDefNode at 0x000002589AA43EB0>, 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'REPTIMPLDEF3', <function createImplBodyNode at 0x000002589AA43F40>, 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr', <function createImplDefNode at 0x000002589AA43EB0>, <function createLeaf at 0x0000025899A30700>, 'id', 'impl'])
impl --> impl

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr', <function createImplDefNode at 0x000002589AA43EB0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3'])
REPTIMPLDEF3 --> ['FUNCDEF', 'REPTIMPLDEF3']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCDEF'])
FUNCDEF --> ['FUNCHEAD', 'FUNCBODY']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['FPARAMSTAIL', <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, 'FPARAMSTAIL'])
FPARAMSTAIL --> ['comma', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMSTAIL4', <function createDimNode at 0x000002589AA43370>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4'])
REPTFPARAMSTAIL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['id']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY'])
FUNCBODY --> ['lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'REPTFUNCBODY1', <function createFuncBodyNode at 0x000002589AA43BE0>, 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['id']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['dot', 'STATESTART']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['dot', 'STATESTART']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['return', 'lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createReturnNode at 0x000002589AA436D0>, 'rpar', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar', 'return'])
return --> return

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3'])
REPTIMPLDEF3 --> ['FUNCDEF', 'REPTIMPLDEF3']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCDEF'])
FUNCDEF --> ['FUNCHEAD', 'FUNCBODY']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY'])
FUNCBODY --> ['lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'REPTFUNCBODY1', <function createFuncBodyNode at 0x000002589AA43BE0>, 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['floatlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'floatlit'])
floatlit --> floatlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['MULTOP', 'FACTOR', <function createMultNode at 0x000002589AA581F0>, 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'FACTOR', 'MULTOP'])
MULTOP --> ['mult']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'FACTOR', 'mult'])
mult --> mult

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a *
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['ADDOP', 'TERM', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'TERM', 'ADDOP'])
ADDOP --> ['plus']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'TERM', 'plus'])
plus --> plus

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x +
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['return', 'lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createReturnNode at 0x000002589AA436D0>, 'rpar', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar', 'return'])
return --> return

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3'])
REPTIMPLDEF3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['IMPLDEF']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'IMPLDEF'])
IMPLDEF --> ['impl', 'id', <function createLeaf at 0x0000025899A30700>, <function createImplDefNode at 0x000002589AA43EB0>, 'lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'REPTIMPLDEF3', <function createImplBodyNode at 0x000002589AA43F40>, 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr', <function createImplDefNode at 0x000002589AA43EB0>, <function createLeaf at 0x0000025899A30700>, 'id', 'impl'])
impl --> impl

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr', <function createImplDefNode at 0x000002589AA43EB0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3'])
REPTIMPLDEF3 --> ['FUNCDEF', 'REPTIMPLDEF3']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCDEF'])
FUNCDEF --> ['FUNCHEAD', 'FUNCBODY']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY'])
FUNCBODY --> ['lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'REPTFUNCBODY1', <function createFuncBodyNode at 0x000002589AA43BE0>, 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['MULTOP', 'FACTOR', <function createMultNode at 0x000002589AA581F0>, 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'FACTOR', 'MULTOP'])
MULTOP --> ['mult']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'FACTOR', 'mult'])
mult --> mult

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result *
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['ADDOP', 'TERM', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'TERM', 'ADDOP'])
ADDOP --> ['plus']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'TERM', 'plus'])
plus --> plus

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x +
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['MULTOP', 'FACTOR', <function createMultNode at 0x000002589AA581F0>, 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'FACTOR', 'MULTOP'])
MULTOP --> ['mult']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'FACTOR', 'mult'])
mult --> mult

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result *
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['ADDOP', 'TERM', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'TERM', 'ADDOP'])
ADDOP --> ['plus']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'TERM', 'plus'])
plus --> plus

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x +
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['return', 'lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createReturnNode at 0x000002589AA436D0>, 'rpar', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar', 'return'])
return --> return

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3'])
REPTIMPLDEF3 --> ['FUNCDEF', 'REPTIMPLDEF3']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCDEF'])
FUNCDEF --> ['FUNCHEAD', 'FUNCBODY']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['FPARAMSTAIL', <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, 'FPARAMSTAIL'])
FPARAMSTAIL --> ['comma', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMSTAIL4', <function createDimNode at 0x000002589AA43370>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4'])
REPTFPARAMSTAIL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['FPARAMSTAIL', <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, 'FPARAMSTAIL'])
FPARAMSTAIL --> ['comma', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMSTAIL4', <function createDimNode at 0x000002589AA43370>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4'])
REPTFPARAMSTAIL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['id']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY'])
FUNCBODY --> ['lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'REPTFUNCBODY1', <function createFuncBodyNode at 0x000002589AA43BE0>, 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['id']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['dot', 'STATESTART']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['ADDOP', 'TERM', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'TERM', 'ADDOP'])
ADDOP --> ['plus']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'TERM', 'plus'])
plus --> plus

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a +
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM'])
RIGHTRECTERM --> ['MULTOP', 'FACTOR', <function createMultNode at 0x000002589AA581F0>, 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'FACTOR', 'MULTOP'])
MULTOP --> ['mult']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'FACTOR', 'mult'])
mult --> mult

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b *
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM', <function createMultNode at 0x000002589AA581F0>, <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', <function createAddNode at 0x000002589AA58160>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['dot', 'STATESTART']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['dot', 'STATESTART']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['return', 'lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createReturnNode at 0x000002589AA436D0>, 'rpar', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar', 'return'])
return --> return

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3'])
REPTIMPLDEF3 --> ['FUNCDEF', 'REPTIMPLDEF3']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCDEF'])
FUNCDEF --> ['FUNCHEAD', 'FUNCBODY']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['FPARAMSTAIL', <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, 'FPARAMSTAIL'])
FPARAMSTAIL --> ['comma', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMSTAIL4', <function createDimNode at 0x000002589AA43370>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4'])
REPTFPARAMSTAIL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['FPARAMSTAIL', <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, 'FPARAMSTAIL'])
FPARAMSTAIL --> ['comma', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMSTAIL4', <function createDimNode at 0x000002589AA43370>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4'])
REPTFPARAMSTAIL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['id']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'FUNCBODY'])
FUNCBODY --> ['lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'REPTFUNCBODY1', <function createFuncBodyNode at 0x000002589AA43BE0>, 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['id']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['dot', 'STATESTART']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['dot', 'STATESTART']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['dot', 'STATESTART']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['return', 'lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createReturnNode at 0x000002589AA436D0>, 'rpar', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar', 'return'])
return --> return

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar', <function createReturnNode at 0x000002589AA436D0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'REPTIMPLDEF3'])
REPTIMPLDEF3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createImplBodyNode at 0x000002589AA43F40>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['FUNCDEF']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCDEF'])
FUNCDEF --> ['FUNCHEAD', 'FUNCBODY']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['void']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'void'])
void --> void

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY'])
FUNCBODY --> ['lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'REPTFUNCBODY1', <function createFuncBodyNode at 0x000002589AA43BE0>, 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['FUNCDEF']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCDEF'])
FUNCDEF --> ['FUNCHEAD', 'FUNCBODY']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['void']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'void'])
void --> void

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY'])
FUNCBODY --> ['lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'REPTFUNCBODY1', <function createFuncBodyNode at 0x000002589AA43BE0>, 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['FUNCDEF']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCDEF'])
FUNCDEF --> ['FUNCHEAD', 'FUNCBODY']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['FPARAMSTAIL', <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, 'FPARAMSTAIL'])
FPARAMSTAIL --> ['comma', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMSTAIL4', <function createDimNode at 0x000002589AA43370>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4', <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMSTAIL4'])
REPTFPARAMSTAIL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY'])
FUNCBODY --> ['lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'REPTFUNCBODY1', <function createFuncBodyNode at 0x000002589AA43BE0>, 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['FUNCDEF']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCDEF'])
FUNCDEF --> ['FUNCHEAD', 'FUNCBODY']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTFPARAMS3', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'REPTFPARAMS4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['ARRAYSIZE', 'REPTFPARAMS3']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', 'ARRAYSIZE'])
ARRAYSIZE --> ['lsqbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'ENDBR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', 'ENDBR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lsqbr'])
lsqbr --> lsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', 'ENDBR'])
ENDBR --> ['intlit', <function createLeaf at 0x0000025899A30700>, <function createLeafDim at 0x000002589AA430A0>, 'rsqbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', 'rsqbr', <function createLeafDim at 0x000002589AA430A0>, <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', 'rsqbr'])
rsqbr --> rsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['ARRAYSIZE', 'REPTFPARAMS3']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', 'ARRAYSIZE'])
ARRAYSIZE --> ['lsqbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'ENDBR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', 'ENDBR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lsqbr'])
lsqbr --> lsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', 'ENDBR'])
ENDBR --> ['intlit', <function createLeaf at 0x0000025899A30700>, <function createLeafDim at 0x000002589AA430A0>, 'rsqbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', 'rsqbr', <function createLeafDim at 0x000002589AA430A0>, <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3', 'rsqbr'])
rsqbr --> rsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTFPARAMS3'])
REPTFPARAMS3 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'REPTFPARAMS4'])
REPTFPARAMS4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3])
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['TYPE']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY'])
FUNCBODY --> ['lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'REPTFUNCBODY1', <function createFuncBodyNode at 0x000002589AA43BE0>, 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0'])
REPTPROG0 --> ['STRUCTORIMPLORFUNC', 'REPTPROG0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'STRUCTORIMPLORFUNC'])
STRUCTORIMPLORFUNC --> ['FUNCDEF']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCDEF'])
FUNCDEF --> ['FUNCHEAD', 'FUNCBODY']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', 'FUNCHEAD'])
FUNCHEAD --> ['func', 'id', <function createLeaf at 0x0000025899A30700>, 'lpar', 'FPARAMS', <function createParamListNode at 0x000002589AA43490>, 'rpar', 'arrow', 'RETURNTYPE', <function createLeafType at 0x000002589AA43130>, <function createFuncDefNode at 0x000002589AA43520>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id', 'func'])
func --> func

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'FPARAMS'])
FPARAMS --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar', <function createParamListNode at 0x000002589AA43490>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main()
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE', 'arrow'])
arrow --> arrow

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() ->
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'RETURNTYPE'])
RETURNTYPE --> ['void']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY', <function createFuncDefNode at 0x000002589AA43520>, <function createLeafType at 0x000002589AA43130>, 'void'])
void --> void

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'FUNCBODY'])
FUNCBODY --> ['lcurbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'REPTFUNCBODY1', <function createFuncBodyNode at 0x000002589AA43BE0>, 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', <function createLeafEpsilon at 0x000002589AA432E0>, 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['id']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['id']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['id']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['id']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['float']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'float'])
float --> float

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['ARRAYSIZE', 'REPTVARDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ARRAYSIZE'])
ARRAYSIZE --> ['lsqbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'ENDBR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ENDBR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lsqbr'])
lsqbr --> lsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ENDBR'])
ENDBR --> ['intlit', <function createLeaf at 0x0000025899A30700>, <function createLeafDim at 0x000002589AA430A0>, 'rsqbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'rsqbr', <function createLeafDim at 0x000002589AA430A0>, <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'rsqbr'])
rsqbr --> rsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['ARRAYSIZE', 'REPTVARDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ARRAYSIZE'])
ARRAYSIZE --> ['lsqbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'ENDBR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ENDBR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lsqbr'])
lsqbr --> lsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ENDBR'])
ENDBR --> ['intlit', <function createLeaf at 0x0000025899A30700>, <function createLeafDim at 0x000002589AA430A0>, 'rsqbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'rsqbr', <function createLeafDim at 0x000002589AA430A0>, <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'rsqbr'])
rsqbr --> rsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['VARDECL']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECL'])
VARDECL --> ['let', 'id', <function createLeaf at 0x0000025899A30700>, 'colon', 'TYPE', <function createLeafType at 0x000002589AA43130>, 'REPTVARDECL4', <function createDimNode at 0x000002589AA43370>, <function createVardeclNode at 0x000002589AA43400>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id', 'let'])
let --> let

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE', 'colon'])
colon --> colon

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j:
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'TYPE'])
TYPE --> ['integer']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', <function createLeafType at 0x000002589AA43130>, 'integer'])
integer --> integer

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['ARRAYSIZE', 'REPTVARDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ARRAYSIZE'])
ARRAYSIZE --> ['lsqbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'ENDBR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ENDBR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lsqbr'])
lsqbr --> lsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ENDBR'])
ENDBR --> ['intlit', <function createLeaf at 0x0000025899A30700>, <function createLeafDim at 0x000002589AA430A0>, 'rsqbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'rsqbr', <function createLeafDim at 0x000002589AA430A0>, <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'rsqbr'])
rsqbr --> rsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['ARRAYSIZE', 'REPTVARDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ARRAYSIZE'])
ARRAYSIZE --> ['lsqbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'ENDBR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ENDBR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lsqbr'])
lsqbr --> lsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ENDBR'])
ENDBR --> ['intlit', <function createLeaf at 0x0000025899A30700>, <function createLeafDim at 0x000002589AA430A0>, 'rsqbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'rsqbr', <function createLeafDim at 0x000002589AA430A0>, <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'rsqbr'])
rsqbr --> rsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['ARRAYSIZE', 'REPTVARDECL4']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ARRAYSIZE'])
ARRAYSIZE --> ['lsqbr', <function createLeafEpsilon at 0x000002589AA432E0>, 'ENDBR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ENDBR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lsqbr'])
lsqbr --> lsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'ENDBR'])
ENDBR --> ['intlit', <function createLeaf at 0x0000025899A30700>, <function createLeafDim at 0x000002589AA430A0>, 'rsqbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'rsqbr', <function createLeafDim at 0x000002589AA430A0>, <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4', 'rsqbr'])
rsqbr --> rsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'REPTVARDECL4'])
REPTVARDECL4 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createVardeclNode at 0x000002589AA43400>, <function createDimNode at 0x000002589AA43370>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['IDNEST', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'IDNEST'])
IDNEST --> ['dot', 'id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'VARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'APARAMS', <function createFuncParamList at 0x000002589AA43B50>, 'rpar']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS'])
APARAMS --> [<function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, 'REPTAPARAMS1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1'])
REPTAPARAMS1 --> ['APARAMSTAIL', 'REPTAPARAMS1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', 'APARAMSTAIL'])
APARAMSTAIL --> ['comma', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['floatlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'floatlit'])
floatlit --> floatlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1'])
REPTAPARAMS1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['IDNEST', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'IDNEST'])
IDNEST --> ['dot', 'id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'VARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'APARAMS', <function createFuncParamList at 0x000002589AA43B50>, 'rpar']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS'])
APARAMS --> [<function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, 'REPTAPARAMS1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['SIGN', <function createLeafSign at 0x000002589AA43250>, 'FACTOR', <function createSignedNode at 0x000002589AA58040>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createSignedNode at 0x000002589AA58040>, 'FACTOR', <function createLeafSign at 0x000002589AA43250>, 'SIGN'])
SIGN --> ['minus']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createSignedNode at 0x000002589AA58040>, 'FACTOR', <function createLeafSign at 0x000002589AA43250>, 'minus'])
minus --> minus

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createSignedNode at 0x000002589AA58040>, 'FACTOR'])
FACTOR --> ['floatlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createSignedNode at 0x000002589AA58040>, <function createLeaf at 0x0000025899A30700>, 'floatlit'])
floatlit --> floatlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1'])
REPTAPARAMS1 --> ['APARAMSTAIL', 'REPTAPARAMS1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', 'APARAMSTAIL'])
APARAMSTAIL --> ['comma', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['floatlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'floatlit'])
floatlit --> floatlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1'])
REPTAPARAMS1 --> ['APARAMSTAIL', 'REPTAPARAMS1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', 'APARAMSTAIL'])
APARAMSTAIL --> ['comma', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['floatlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'floatlit'])
floatlit --> floatlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1'])
REPTAPARAMS1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['dot', 'STATESTART']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['IDNEST', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'IDNEST'])
IDNEST --> ['dot', 'id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'VARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'APARAMS', <function createFuncParamList at 0x000002589AA43B50>, 'rpar']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS'])
APARAMS --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f()
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'APARAMS', <function createFuncParamList at 0x000002589AA43B50>, 'rpar', 'REPTSTATEFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS'])
APARAMS --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined()
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC'])
REPTSTATEFUNC --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'APARAMS', <function createFuncParamList at 0x000002589AA43B50>, 'rpar', 'REPTSTATEFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS'])
APARAMS --> [<function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, 'REPTAPARAMS1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1'])
REPTAPARAMS1 --> ['APARAMSTAIL', 'REPTAPARAMS1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', 'APARAMSTAIL'])
APARAMSTAIL --> ['comma', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1'])
REPTAPARAMS1 --> ['APARAMSTAIL', 'REPTAPARAMS1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', 'APARAMSTAIL'])
APARAMSTAIL --> ['comma', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1'])
REPTAPARAMS1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC'])
REPTSTATEFUNC --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'APARAMS', <function createFuncParamList at 0x000002589AA43B50>, 'rpar', 'REPTSTATEFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS'])
APARAMS --> [<function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, 'REPTAPARAMS1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['floatlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'floatlit'])
floatlit --> floatlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1'])
REPTAPARAMS1 --> ['APARAMSTAIL', 'REPTAPARAMS1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', 'APARAMSTAIL'])
APARAMSTAIL --> ['comma', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'comma'])
comma --> comma

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1'])
REPTAPARAMS1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC'])
REPTSTATEFUNC --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['INDICE', 'REPTSTATEVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'INDICE'])
INDICE --> ['lsqbr', 'ARITHEXPR', <function createIndiceNode at 0x000002589AA580D0>, 'rsqbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'ARITHEXPR', 'lsqbr'])
lsqbr --> lsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr'])
rsqbr --> rsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['INDICE', 'REPTSTATEVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'INDICE'])
INDICE --> ['lsqbr', 'ARITHEXPR', <function createIndiceNode at 0x000002589AA580D0>, 'rsqbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'ARITHEXPR', 'lsqbr'])
lsqbr --> lsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr'])
rsqbr --> rsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['INDICE', 'REPTSTATEVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'INDICE'])
INDICE --> ['lsqbr', 'ARITHEXPR', <function createIndiceNode at 0x000002589AA580D0>, 'rsqbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'ARITHEXPR', 'lsqbr'])
lsqbr --> lsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['floatlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'floatlit'])
floatlit --> floatlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr', <function createIndiceNode at 0x000002589AA580D0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0', 'rsqbr'])
rsqbr --> rsqbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'APARAMS', <function createFuncParamList at 0x000002589AA43B50>, 'rpar', 'REPTSTATEFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS'])
APARAMS --> [<function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, 'REPTAPARAMS1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1'])
REPTAPARAMS1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEFUNC'])
REPTSTATEFUNC --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['STATESTART', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['dot', 'STATESTART']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATESTART'])
STATESTART --> ['id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'STATEVARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'STATEVARORFUNC'])
STATEVARORFUNC --> ['REPTSTATEVARORFUNC0', 'REPTSTATEVAR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'REPTSTATEVARORFUNC0'])
REPTSTATEVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', 'REPTSTATEVAR'])
REPTSTATEVAR --> ['ASSIGNOP', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createAssignNode at 0x000002589AA583A0>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'ASSIGNOP'])
ASSIGNOP --> ['equal']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'equal'])
equal --> equal

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x =
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createAssignNode at 0x000002589AA583A0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['VARDECLORSTAT', 'REPTFUNCBODY1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'VARDECLORSTAT'])
VARDECLORSTAT --> ['STATEMENT']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'STATEMENT'])
STATEMENT --> ['while', 'lpar', 'RELEXPR', <function createWhileNode at 0x000002589AA437F0>, 'rpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'STATBLOCK', <function createWhileBlockNode at 0x000002589AA43880>, 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, 'RELEXPR', 'lpar', 'while'])
while --> while

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, 'RELEXPR', 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, 'RELEXPR'])
RELEXPR --> ['ARITHEXPR', 'RELOP', 'ARITHEXPR', <function createConditionNode at 0x000002589AA43760>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'RELOP', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'RELOP', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'RELOP', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'RELOP', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'RELOP', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'RELOP', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'RELOP', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'RELOP', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'RELOP', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'RELOP', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'RELOP', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'RELOP', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'RELOP', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'RELOP'])
RELOP --> ['leq']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR', 'leq'])
leq --> leq

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <=
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['intlit', <function createLeaf at 0x0000025899A30700>]
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', <function createLeaf at 0x0000025899A30700>, 'intlit'])
intlit --> intlit

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar', <function createWhileNode at 0x000002589AA437F0>, <function createConditionNode at 0x000002589AA43760>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK', <function createLeafEpsilon at 0x000002589AA432E0>, 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'STATBLOCK'])
STATBLOCK --> ['lcurbr', 'REPTSTATBLOCK1', 'rcurbr']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'lcurbr'])
lcurbr --> lcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1'])
REPTSTATBLOCK1 --> ['STATEMENT', 'REPTSTATBLOCK1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'STATEMENT'])
STATEMENT --> ['write', 'lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createWriteNode at 0x000002589AA435B0>, 'rpar', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar', 'write'])
write --> write

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1'])
REPTSTATBLOCK1 --> ['STATEMENT', 'REPTSTATBLOCK1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'STATEMENT'])
STATEMENT --> ['write', 'lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createWriteNode at 0x000002589AA435B0>, 'rpar', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar', 'write'])
write --> write

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['IDNEST', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'IDNEST'])
IDNEST --> ['dot', 'id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'VARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'APARAMS', <function createFuncParamList at 0x000002589AA43B50>, 'rpar']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS'])
APARAMS --> [<function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, 'REPTAPARAMS1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1'])
REPTAPARAMS1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter))
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter));
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1'])
REPTSTATBLOCK1 --> ['STATEMENT', 'REPTSTATBLOCK1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'STATEMENT'])
STATEMENT --> ['write', 'lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, <function createWriteNode at 0x000002589AA435B0>, 'rpar', 'semi']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar', 'write'])
write --> write

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter));
    write
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'EXPR', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter));
    write(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter));
    write(f2
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['IDNEST', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'IDNEST'])
IDNEST --> ['dot', 'id', <function createLeaf at 0x0000025899A30700>, <function createAttributeNode at 0x000002589AA584C0>, 'VARORFUNC']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id', 'dot'])
dot --> dot

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter));
    write(f2.
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createAttributeNode at 0x000002589AA584C0>, <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter));
    write(f2.evaluate
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['lpar', <function createLeafEpsilon at 0x000002589AA432E0>, 'APARAMS', <function createFuncParamList at 0x000002589AA43B50>, 'rpar']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS', <function createLeafEpsilon at 0x000002589AA432E0>, 'lpar'])
lpar --> lpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter));
    write(f2.evaluate(
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'APARAMS'])
APARAMS --> [<function createLeafEpsilon at 0x000002589AA432E0>, 'EXPR', <function createExprNode at 0x000002589AA58430>, 'REPTAPARAMS1']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'EXPR'])
EXPR --> ['ARITHEXPR', 'RELEXPREND']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'ARITHEXPR'])
ARITHEXPR --> ['TERM', 'RIGHTRECARITHEXPR']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'TERM'])
TERM --> ['FACTOR', 'RIGHTRECTERM']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'FACTOR'])
FACTOR --> ['id', <function createLeaf at 0x0000025899A30700>, 'VARORFUNC', 'REPTFACTOR2']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC', <function createLeaf at 0x0000025899A30700>, 'id'])
id --> id

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter));
    write(f2.evaluate(counter
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'VARORFUNC'])
VARORFUNC --> ['REPTVARORFUNC0']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'REPTVARORFUNC0'])
REPTVARORFUNC0 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1', <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'REPTAPARAMS1'])
REPTAPARAMS1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar', <function createFuncParamList at 0x000002589AA43B50>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter));
    write(f2.evaluate(counter)
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'REPTFACTOR2'])
REPTFACTOR2 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'RIGHTRECTERM'])
RIGHTRECTERM --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'RIGHTRECARITHEXPR'])
RIGHTRECARITHEXPR --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'RELEXPREND'])
RELEXPREND --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar', <function createWriteNode at 0x000002589AA435B0>, <function createExprNode at 0x000002589AA58430>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi', 'rpar'])
rpar --> rpar

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter));
    write(f2.evaluate(counter))
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter));
    write(f2.evaluate(counter));
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'REPTSTATBLOCK1'])
REPTSTATBLOCK1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr', 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi', <function createWhileBlockNode at 0x000002589AA43880>, 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter));
    write(f2.evaluate(counter));
  }
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1', 'semi'])
semi --> semi

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter));
    write(f2.evaluate(counter));
  };
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'REPTFUNCBODY1'])
REPTFUNCBODY1 --> ['epsilon']
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr', <function createFuncBodyNode at 0x000002589AA43BE0>, 'epsilon'])
epsilon --> epsilon
deque(['$', <function createProgNode at 0x000002589AA58550>, 'REPTPROG0', 'rcurbr'])
rcurbr --> rcurbr

struct polynomial {
    public func evaluate(x: float) -> float;
    public func evaluate2(x: float) -> float;
};
struct polynomial {
    public func evaluate(x: float) -> float;
        public func evaluate(x: integer) -> integer;
};
struct linear inherits polynomial {
    private let a: float;
    private let b: float;
    private let b: integer;

    public func build(a: float, b: float) -> linear;
    public func evaluate(x: float) -> float;
};

struct quadratic inherits polynomial {
    private let a: float;
    private let b: float;
    private let c: float;

    public func build(a: float, b: float, c: float) -> quadratic;
    public func evaluate(x: float) -> float;
};

struct c inherits e {
    private let a: integer;
};

struct d inherits c {
    private let b: integer;
};

struct e inherits d {
    private let c: integer;
};



impl polynomial {
  func evaluate(x: float) -> float
  {
    return (0);
  }
}

impl linear {
  func build(a: float, b: float) -> linear
  {
    let new_function: linear;
    new_function.a = a;
    new_function.b = b;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}

impl quadratic {
  func evaluate(x: float) -> float
  {
    let result: float;

    result = a;
    result = result * x + b;
    result = result * x + c;
    return (result);
  }
  func build(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic ;
    new_function.a = a + b * 3;
    new_function.b = b;
    new_function.c = 1;
    return (1);
  }
  func build2(a: float, b: float, c: float) -> quadratic
  {
    let new_function: quadratic;
    new_function.a = a;
    new_function.b = b;
    new_function.c = c;
    return (new_function);
  }
}

func f(i: integer) -> void {}
func f(i: integer) -> void {}
func f(i: integer, j: integer) -> integer {}

func f3(p1: integer[2][3]) -> integer {}



func main() -> void
{
  let a: a;
  let c: c;
  let f1: linear;
  let f2: quadratic;
  let counter: integer;
  let counter: float;
  let i: integer[2][3];
  let j: integer[1][2][3];
  f1 = f1.build(2, 3.5);
  f2 = f2.build(-2.0, 1.0, 0.0);
  c.b = 1;
  counter = c.f();
  undefined();
  counter = a;
  f(1,1,1);
  f(1.2,1);
  i[2] = 1;
  i[2][1.3] = 2;
  f3(j);
  counter.x = 1;
  while(counter <= 10)
  {
    write(counter);
    write(f1.evaluate(counter));
    write(f2.evaluate(counter));
  };
}
